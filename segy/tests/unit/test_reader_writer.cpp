#include "../../include/segy/segy.hpp"
#include <cassert>
#include <iostream>
#include <filesystem>
#include <cmath>

using namespace segy;

// ============================================================================
// READER/WRITER INTEGRATION TESTS
// ============================================================================

void test_write_read_roundtrip() {
    const std::filesystem::path test_file = "/tmp/test_roundtrip.segy";

    // Clean up any existing file
    std::filesystem::remove(test_file);

    // Create headers
    TextualHeader textual;
    textual.set_line(1, "C01 TEST SEG-Y FILE");
    textual.set_line(2, "C02 Generated by SEG-Y library");
    textual.set_line(40, "C40 END TEXTUAL HEADER");

    BinaryHeader binary;
    binary.set_job_id(12345);
    binary.set_line_number(1);
    binary.set_sample_interval(4000); // 4ms
    binary.set_samples_per_trace(100);
    binary.set_sample_format(SampleFormat::IEEEFloat);

    // Create writer
    Writer<float> writer(test_file, textual, binary);

    // Write 10 traces
    for (int t = 0; t < 10; ++t) {
        TraceHeader trace_header;
        trace_header.set_trace_sequence(t + 1);
        trace_header.set_inline_number(100 + t);
        trace_header.set_crossline_number(200);
        trace_header.set_num_samples(100);
        trace_header.set_sample_interval(4000);

        Trace<float> trace(trace_header, 100);
        auto samples = trace.samples();

        // Generate synthetic data
        for (size_t i = 0; i < 100; ++i) {
            samples[i] = std::sin(2.0f * 3.14159f * i / 100.0f) * (t + 1);
        }

        writer.write_trace(trace);
    }

    writer.close();

    // Verify file exists
    assert(std::filesystem::exists(test_file));

    // Read back
    Reader<float> reader(test_file);

    // Verify headers
    assert(reader.binary_header().job_id() == 12345);
    assert(reader.binary_header().sample_interval() == 4000);
    assert(reader.binary_header().samples_per_trace() == 100);
    assert(reader.num_traces() == 10);

    // Verify textual header
    auto line1 = reader.textual_header().get_line(1);
    assert(line1.substr(0, 19) == "C01 TEST SEG-Y FILE");

    // Verify traces
    for (size_t t = 0; t < 10; ++t) {
        auto trace = reader.read_trace(t);

        assert(trace.header().trace_sequence() == static_cast<int32_t>(t + 1));
        assert(trace.header().inline_number() == static_cast<int32_t>(100 + t));
        assert(trace.num_samples() == 100);

        // Verify first few samples
        auto samples = trace.samples();
        float expected_0 = std::sin(0.0f) * (t + 1);
        float expected_25 = std::sin(2.0f * 3.14159f * 25.0f / 100.0f) * (t + 1);

        assert(std::abs(samples[0] - expected_0) < 0.001f);
        assert(std::abs(samples[25] - expected_25) < 0.01f);
    }

    // Test range reading
    auto traces_2_5 = reader.read_traces(2, 5);
    assert(traces_2_5.size() == 3); // [2, 5) = 3 traces

    // Clean up
    std::filesystem::remove(test_file);

    std::cout << "âœ“ Write/Read roundtrip tests passed\n";
}

void test_write_read_ibm_format() {
    const std::filesystem::path test_file = "/tmp/test_ibm.segy";
    std::filesystem::remove(test_file);

    // Headers
    TextualHeader textual;
    textual.set_line(1, "C01 IBM FLOAT TEST");

    BinaryHeader binary;
    binary.set_sample_interval(2000);
    binary.set_samples_per_trace(50);
    binary.set_sample_format(SampleFormat::IBMFloat); // IBM format

    // Write
    Writer<float> writer(test_file, textual, binary);

    TraceHeader trace_header;
    trace_header.set_trace_sequence(1);
    trace_header.set_num_samples(50);
    trace_header.set_sample_interval(2000);

    Trace<float> trace(trace_header, 50);
    auto samples = trace.samples();
    for (size_t i = 0; i < 50; ++i) {
        samples[i] = static_cast<float>(i) * 2.5f;
    }

    writer.write_trace(trace);
    writer.close();

    // Read back
    Reader<float> reader(test_file);
    auto read_trace = reader.read_trace(0);

    // Verify (IBM has some precision loss)
    auto read_samples = read_trace.samples();
    for (size_t i = 0; i < 50; ++i) {
        float expected = static_cast<float>(i) * 2.5f;
        assert(std::abs(read_samples[i] - expected) < 0.1f);
    }

    std::filesystem::remove(test_file);

    std::cout << "âœ“ IBM format tests passed\n";
}

void test_read_all_traces() {
    const std::filesystem::path test_file = "/tmp/test_all.segy";
    std::filesystem::remove(test_file);

    // Create small file
    TextualHeader textual;
    BinaryHeader binary;
    binary.set_sample_interval(4000);
    binary.set_samples_per_trace(10);
    binary.set_sample_format(SampleFormat::IEEEFloat);

    Writer<float> writer(test_file, textual, binary);

    for (int i = 0; i < 5; ++i) {
        TraceHeader th;
        th.set_trace_sequence(i);
        th.set_num_samples(10);

        Trace<float> trace(th, 10);
        writer.write_trace(trace);
    }
    writer.close();

    // Read all at once
    Reader<float> reader(test_file);
    auto all_traces = reader.read_all_traces();

    assert(all_traces.size() == 5);
    for (size_t i = 0; i < 5; ++i) {
        assert(all_traces[i].header().trace_sequence() == static_cast<int32_t>(i));
    }

    std::filesystem::remove(test_file);

    std::cout << "âœ“ Read all traces tests passed\n";
}

int main() {
    std::cout << "Running reader/writer tests...\n";

    test_write_read_roundtrip();
    test_write_read_ibm_format();
    test_read_all_traces();

    std::cout << "\nðŸŽ‰ All reader/writer tests passed!\n";
    return 0;
}
